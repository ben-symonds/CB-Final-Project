'use-strict';

const { MongoClient } = require('mongodb');
require('dotenv').config();
const { MONGO_URI } = process.env;
const options = {
    useNewUrlParser: true,
    useUnifiedTopology: true,
};

//adds new user to 'Users' collection in DB 
const postUser = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    //req body contains the new user's username and an id generated by firebase
    const newUser = req.body;

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Users').insertOne(newUser);

        result
        ? res.status(200).json({status: 200, message: 'New User Added to Database'})
        : res.status(400).json({status: 400, message: 'Could Not Add User to Database'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

//add new cluster to 'Clusters' collection in DB
const postCluster = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    //req body contains the new user's username and an id generated by firebase
    const newCluster = req.body;

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').insertOne(newCluster);

        result
        ? res.status(200).json({status: 200, message: 'New Cluster Added to Database'})
        : res.status(400).json({status: 400, message: 'Could Not Add Cluster to Database'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

//retrives cluster object from 'Clusters' collection in DB
const getCluster = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);

    const id = (req.params.id);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').findOne({clusterId: id});

        result
        ? res.status(200).json({status: 200, data: result,  message: 'Cluster Retrived'})
        : res.status(400).json({status: 400, message: 'Cluster Not Found'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const postClusterItem = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);

    const newClusterItem = req.body;
    
    const id = (req.params.id);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').updateOne(
            {clusterId: id},
            { $push: { items: newClusterItem}}
        )
        result
        ? res.status(200).json({status: 200, message: 'New Item Added to Cluster'})
        : res.status(400).json({status: 400, message: 'Could Not Add Item to Cluster'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const getUserClusters = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);

    const id = (req.params.id);

    try {
        
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').find({userId: id}).toArray();

        result
        ? res.status(200).json({status: 200, data: result,  message: 'Clusters Retrived'})
        : res.status(400).json({status: 400, message: 'Clusters Not Found'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
} 

const deleteClusterItem = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    
    const clusterId = (req.params.clusterId);

    const itemId = (req.params.itemId);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').updateOne(
            {clusterId: clusterId},
            {$pull: {items: {itemId: itemId}}}
        )

        result
        ? res.status(200).json({status: 200, message: 'Deleted Item From Cluster'})
        : res.status(400).json({status: 400, message: 'Could Not Delete Item From Cluster'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const deleteCluster = async (req, res) => {

    const client = new MongoClient(MONGO_URI, options);
    
    const id = (req.params.id);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').deleteOne({clusterId: id})

        result
        ? res.status(200).json({status: 200, message: 'Deleted Item From Cluster'})
        : res.status(400).json({status: 400, message: 'Could Not Delete Item From Cluster'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const getPublicClusters = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);

    try {
        
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').find({visibility: 'public'}).toArray();

        result
        ? res.status(200).json({status: 200, data: result,  message: 'Public Clusters Retrived'})
        : res.status(400).json({status: 400, message: 'Public Clusters Not Found'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
} 

const getPublicClustersByTag = async (req, res) => {

    const tag = req.params.tag;

    console.log(tag);

    const client = new MongoClient(MONGO_URI, options);

    try {
        
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').find({visibility: 'public', tags: tag}).toArray();

        result.length
        ? res.status(200).json({status: 200, data: result,  message: 'Public Clusters Retrived By Tag'})
        : res.status(400).json({status: 400, message: tag});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const getFeaturedTags = async (req,res) => {

    const client = new MongoClient(MONGO_URI, options);

    try {
        
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').find({visibility: 'public'}).toArray();

        let tagsArray = [];
        result.forEach(item => {
            tagsArray = tagsArray.concat(item.tags);
        })

        const shuffledArray = tagsArray.sort(() => 0.5 - Math.random());

        const featuredArray = shuffledArray.slice(0, 5);

        result.length
        ? res.status(200).json({status: 200, data: featuredArray,  message: 'Featured Tags Retrieved'})
        : res.status(400).json({status: 400, message: 'Not Enough Tags in Public Clusters'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const getUsername = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);

    const id = (req.params.id);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Users').findOne({id: id});

        result
        ? res.status(200).json({status: 200, data: result.username,  message: 'Cluster Retrived'})
        : res.status(400).json({status: 400, message: 'Cluster Not Found'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const getPublicClustersById = async (req, res) => {

    const id = req.params.id;

    const client = new MongoClient(MONGO_URI, options);

    try {
        
        await client.connect();
        const db = client.db('Cluster');

        const userExists = await db.collection('Clusters').find({userId: id}).toArray();

        if(userExists.length) {
            const result = await db.collection('Clusters').find({visibility: 'public', userId: id}).toArray();
            result.length
            ? res.status(200).json({status: 200, data: result,  message: 'Public Clusters Retrived By Id'})
            : res.status(400).json({status: 400, message: `No public clusters were found by this user`});
    
        } else {
            res.status(400).json({status: 400, message: `User does not exist`});
        }
        
        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const patchClusterVisibility = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    
    const id = (req.params.id);

    const newVisibility = (req.params.visibility);

    try {
        await client.connect();
        const db = client.db('Cluster');
        const result = await db.collection('Clusters').updateOne(
            {clusterId: id},
            {'$set': {visibility: newVisibility}}
        )

        result
        ? res.status(200).json({status: 200, message: 'Cluster Visibility Updated'})
        : res.status(400).json({status: 400, message: 'Could Not Update Visibility'});

        client.close();
    }
    catch(error){
        console.log(error.stack)
    }
}

const patchClusterTags = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    
    const id = (req.params.id);

    const newTags = (req.params.tags);


    try {
        await client.connect();
        const db = client.db('Cluster');

        let result;

        if(newTags === 'empty') {
            result = await db.collection('Clusters').updateOne(
                {clusterId: id},
                {'$set': {tags: []}}
            )
            result
            ? res.status(200).json({status: 200, message: 'Cluster Visibility Updated'})
            : res.status(400).json({status: 400, message: 'Could Not Update Visibility'});
    
            client.close();
        } else {
            const newTagsArr = newTags.split(',');
            result = await db.collection('Clusters').updateOne(
                {clusterId: id},
                {'$set': {tags: newTagsArr}}
            )
            result
            ? res.status(200).json({status: 200, message: 'Cluster Visibility Updated'})
            : res.status(400).json({status: 400, message: 'Could Not Update Visibility'});
    
            client.close();
        }

    }
    catch(error){
        console.log(error.stack)
    }

    client.close();
}

const patchUserInfo = async (req, res) => {
    const client = new MongoClient(MONGO_URI, options);
    
    const id = (req.params.id);

    const newUsername = (req.params.newUsername);

    try {
        await client.connect();
        const db = client.db('Cluster');

        result = await db.collection('Users').updateOne(
                {id: id},
                {'$set': {username: newUsername}}
            )

        result
        ? res.status(200).json({status: 200, message: 'User Updated'})
        : res.status(400).json({status: 400, message: 'Could Not Update User'});
    
        client.close();
    }

    catch(error){
        console.log(error.stack)
    }

    client.close();

}

const deleteUser = async (req, res) => {

    const client = new MongoClient(MONGO_URI, options);
    
    const id = (req.params.id);

    try {
        await client.connect();
        const db = client.db('Cluster');

        await db.collection('Users').deleteOne({id: id});

        await db.collection('Clusters').deleteMany({userId: id});

        res.status(200).json({status: 200, message: 'User Deleted'});
    
        client.close();
    }

    catch(error){
        console.log(error.stack)
    }

    client.close();

}

module.exports = {
    postUser,
    postCluster,
    getCluster,
    postClusterItem,
    getUserClusters,
    deleteClusterItem,
    deleteCluster,
    getPublicClusters,
    getPublicClustersByTag,
    getFeaturedTags,
    getUsername,
    getPublicClustersById,
    patchClusterVisibility,
    patchClusterTags,
    patchUserInfo, 
    deleteUser
}